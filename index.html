<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>TRABALHO 1 DE ESTRUTURA DE DADOS</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>ALGORITMOS DE ORDENAÇÃO DE DADOS</h2>
			</section>
			<section>
				<h3>Este Trabalho</h3>
				<section>
					<p>O Presente trabalho descreve os algoritmos de odenação citados abaixo, baseando-se no
						funcionamento, complexibilidade, estabilidade, representação gráfica e a devida implementação na
						linguadem de programação C</p>
				</section>
				<section>
					<ul>
						<li>Insertion Sort</li>
						<li>Quick Sort</li>
						<li>Shel Sort</li>
						<li>Heap Sort</li>
						<li>Merge Sort</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>INTRODUÇÃO</h3>
				<section>
					<P>Os algoritmos de ordenação são um conjunto de procedimentos que visam organizar uma sequência de
						dados em ordem crescente ou decrescente. </P>
				</section>
				<section>
					<p>Eles são amplamente utilizados em diversas áreas, desde a organização de dados em bancos de dados
						até a criação de gráficos e tabelas em softwares de análise de dados.</p>
				</section>
				<section>
					<p>
						Existem vários tipos de algoritmos de ordenação, cada um com suas próprias características e
						vantagens. Alguns exemplos incluem o Bubble Sort, o Insertion Sort, o Selection Sort, o Merge
						Sort, o Quick Sort, o Shell Sort e o Heap Sort.
					</p>
				</section>
				<section>
					<p>A escolha do algoritmo mais adequado depende do tipo de dados que estão sendo ordenados, do
						tamanho da lista e das necessidades específicas da aplicação.</p>
				</section>
			</section>
			<section>
				<h2>QUICK SORT</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>Quick Sort é um algoritmo eficiente de ordenação por divisão e conquista. Apesar de ser da
						mesma classe de complexidade do  Merge Sort  e do  Heap Sort , o Quick Sort é na prática o
						mais veloz deles, pois suas constantes são menores.</p>
				</section>
				<section>
					<p>
						Foi proposto por Hoare em 1960 e publicado em 1962. É o algoritmo de ordenação interna
						mais rápido que se conhece para uma ampla variedade de situações.
					</p>
				</section>
			</section>
			<section>
				<h3>Funcionamento</h3>
				<section>
					<p>
						O funcionamento do Quick Sort baseia-se em uma rotina fundamental cujo nome
						é particionamento. Particionar significa escolher um número qualquer presente no array,
						chamado de pivot, e colocá-lo em uma posição tal que todos os elementos à esquerda são
						menores ou iguais e todos os elementos à direita são maiores.
					</p>
				</section>
				<section>
					<p>
						A idéia básica do quick sort é dividir o problema de ordenar um conjunto com n itens em
						dois sub-problemas menores.
					</p>
				</section>

			</section>
			<section>
				<h2>Vantagens e Desvantagens</h2>
				<section>
					<p>Vantagens</p>
					<ul>
						<li>É extremamente eficiente para ordenar arquivos de dados.</li>
						<li>Necessita de apenas uma pequena pilha como memória auxiliar.</li>
						<li>Requer O(n log n) comparações em média (caso médio) para ordenar n itens.</li>
					</ul>
				</section>
				<section>
					<p>Desvantagens</p>
					<ul>
						<li>Tem um pior caso O(n2) comparações.</li>
						<li>Sua implementação é delicada e difícil</li>
						<li>Um pequeno engano pode levar a efeitos inesperados para algumas entradas de dados.</li>
						<li>O método não é estável.</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Complexidade</h2>
				<section>
					<p>Sua complexidade no tempo é O(nlogn) no melhor caso e no caso médio e O(n^2) no pior
						caso. Contudo, em geral, o Quicksort apresenta um desempenho superior a outros
						algoritmos similares, como o Merge Sort.</p>
				</section>
			</section>
			<section>
				<h2>Estabilidade</h2>
				<section>
					<p>O Quick Sort não é um algoritmo estável. O modo como o particiona é implementado
						permite que elementos iguais troquem de posições relativas durante a sua execução.</p>
				</section>
				<section>
					<p>É possível implementar uma versão estável do Quick Sort, mas para isso, ao invés de trocar
						o pivot diretamente com a primeira posição, o algoritmo deve fazer sucessivas trocas para
						“afastar” o pivot até a posição desejada – um processo semelhante à inserção ordenada.
						Essa implementação, contudo, piora significativamente o desempenho do Quick Sort.</p>
				</section>
			</section>
			<section>
				<h2>Metodo de partição
				</h2>
				<section>
					<p>Algoritmo para o particionamento</p>
					<ul>
						<li>1 - Escolha arbitrariamente um pivô x. </li>
						<li>2 - Percorra o vetor a partir da esquerda até que v[i] ≥ x. </li>
						<li>3 - Percorra o vetor a partir da direita até que v[j] ≤ x. </li>
						<li>4 - Troque v[i] com v[j]. </li>
						<li>5 - Continue este processo até os apontadores i e j se cruzarem.</li>
					</ul>
				</section>
				<section>
					<p>Ao final, do algoritmo de partição:</p>
					<ul>
						<li>Vetor v[esq..dir] está particionado de tal forma que:</li>
						<li>Os itens em v[esq], v[esq + 1], ..., v[j] são menores ou iguais a x;</li>
						<li>Os itens em v[i], v[i + 1], ..., v[dir] são maiores ou iguais a x.</li>
					</ul>
				</section>
			</section>
			<section>
				<h2 data-id="code-title">Implementação em C</h2>
				<section>
					<p>Particionar usando o esquema de particionamento de Hoare</p>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						int partition(int a[], int low, int high)
						{
							int pivot = a[low];
							int i = low - 1;
							int j = high + 1;
							while (1)
							{
								do {
									i++;
								} while (a[i] < pivot);
						 
								do {
									j--;
								} while (a[j] > pivot);
						 
								if (i >= j) {
									return j;
								}
						 
								swap(a[i], a[j]);
							}
						}
						
						</code></pre>
				</section>
				<section>
					<p>Rotina de classificação rápida</p>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						void quicksort(int a[], int low, int high)
						{
							// condição básica
							if (low >= high) {
								return;
							}
						
							// reorganiza os elementos no pivô
							int pivot = partition(a, low, high);
						
							// se repete no subarray contendo elementos que são menores que o pivô
							quicksort(a, low, pivot);
						
							//recorre em subarray contendo elementos que são maiores que o pivô
							quicksort(a, pivot + 1, high);
						}

						
						</code></pre>
				</section>
				<section>
					<p>Função main()</p>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						int main()
						{
							int arr[10] = {12, 8, 9, 12, 4, 3, 9, 29, 10, 1};
						
							quicksort(arr, 0, 9);
							
							//apresentando o vetor ordenado
							for (int i = 0; i < N; i++) {
								printf("%d\n", arr[i]);
							}
						
							return 0;
						}


						</code></pre>
				</section>
			</section>
			<section>
				<h2>SHELL SORT</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>ShellSort é uma versão aprimorada do algoritmo de InsertionSort, diferindo pelo fato de no lugar
						de considerar o vetor a ser ordenado como um único segmento, ele considera vários segmentos
						sendo aplicado o método de inserção direta em cada um deles. Basicamente o algoritmo passa
						várias vezes pela lista dividindo o grupo maior em menores. </p>
				</section>
				<section>
					<p>
						O algoritmo é eficiente mas razão da sua eficiência ainda não é conhecida, pois ninguém ainda
						foi capaz de analisar o algoritmo a sua análise contém alguns problemas matemáticos muito
						difíceis.
					</p>
				</section>
			</section>
			<section>
				<h3>Funcionamento</h3>
				<section>
					<p>
						O Shellsort troca elementos distantes um do outro. Os itens separados por h posições são
						agrupados e ordenados, o valor de h é decrementado seguindo uma sequencia qualquer (não há uma
						sequencia definitiva) até que atinja o valor unitário, onde a ordenação corresponde ao algoritmo
						de inserção, mas nesse ponto nenhum elemento precisa se mover para uma posição muito distante.
					</p>
				</section>
			</section>
			<section>
				<h3>Complexidade</h3>
				<section>
					<p>A complexidade do algoritmo ainda não é conhecida, ninguém ainda foi capaz de encontrar uma
						fórmula fechada para sua função de complexidade. A sua análise contém alguns problemas
						matemáticos muito difíceis.
					</p>
				</section>
				<section>
					<p>

					</p>
				</section>
			</section>
			<section>
				<h3>Estabilidade</h3>
				<section>
					<p>A complexidade do algoritmo ainda não é conhecida, ninguém ainda foi capaz de encontrar uma
						fórmula fechada para sua função de complexidade. A sua análise contém alguns problemas
						matemáticos muito difíceis.
					</p>
				</section>
				<section>
					<p>
						Quanto a essa característica o algoritmo não é estável
					</p>
				</section>
			</section>
			<section>
				<h3>Estabilidade</h3>
				<section>
					<p>A complexidade do algoritmo ainda não é conhecida, ninguém ainda foi capaz de encontrar uma
						fórmula fechada para sua função de complexidade. A sua análise contém alguns problemas
						matemáticos muito difíceis.
					</p>
				</section>
				<section>
					<p>
						Quanto a essa característica o algoritmo não é estável
					</p>
				</section>
			</section>
			<section>
				<h3>Representação Gráfica</h3>

			</section>
			<section>
				<h3>Implementação Em C</h3>
				<section>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						#include <stdio.h>


							// Shell sort
							void shellSort(int v[], int n) {
							  // Rearrange elements at each n/2, n/4, n/8, ... intervals
							  for (int interval = n / 2; interval > 0; interval /= 2) {
								for (int i = interval; i < n; i += 1) {
								  int temp = v[i];
								  int j;
								  for (j = i; j >= interval && v[j - interval] > temp; j -= interval) {
									v[j] = v[j - interval];
								  }
									v[j] = temp;
								}
							  }
							}
							
							
							// Print an array
							void printv(int v[], int size) {
							  for (int i = 0; i < size; ++i) {
								printf("%d  ", v[i]);
							  }
							  printf("\n");
							}
							
							
							// Driver code
							int main() {
							  int m[] = {9, 8, 3, 7, 5, 6, 4, 1};
							  int size = sizeof(m) / sizeof(m[0]);
							  shellSort(m, size);
							  printf("Sorted array: \n");
							  printv(m, size);
							}
							

						
						</code></pre>
				</section>
			</section>
			<section>
				<h2>Merge Sort</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>O algoritmo de ordenação Merge Sort é um algoritmo de classificação eficiente e recursivo, que
						divide a lista em duas metades iguais, ordena cada metade e, em seguida, combina as duas metades
						ordenadas em uma única lista ordenada.</p>
				</section>
				<section>
					<p>O algoritmo funciona da seguinte maneira:</p>
					<ul>
						<li>Divida a lista em duas metades iguais.</li>
						<li>Ordena recursivamente cada metade.</li>
						<li>Combina as duas metades ordenadas em uma única lista ordenada.</li>
					</ul>
				</section>
				<section>
					<p>
						Divida a lista em duas metades iguais.
						Ordena recursivamente cada metade.
						Combina as duas metades ordenadas em uma única lista ordenada.
					</p>
				</section>
				<section>
					<p>
						Esse processo de dividir, ordenar e combinar é repetido recursivamente até que a lista inteira
						seja ordenada.
					</p>
				</section>
				<section>
					<p>O Merge Sort é um algoritmo eficiente com uma complexidade de tempo de O(nlogn), onde n é o
						tamanho da lista. Ele é amplamente utilizado na prática, especialmente quando há uma grande
						quantidade de dados para serem ordenados.</p>
				</section>
				<section>
					<p>Uma das principais vantagens do Merge Sort é que ele é um algoritmo de classificação estável, o
						que significa que ele preserva a ordem relativa dos elementos com chaves iguais. Além disso, o
						Merge Sort é adequado para dados armazenados em mídia externa, como arquivos, porque minimiza o
						número de acessos ao disco.</p>
				</section>
				<section>
					<p>No entanto, o Merge Sort requer uma quantidade adicional de memória para a lista auxiliar durante
						a etapa de combinação, o que pode ser um problema em algumas situações.</p>
				</section>
				<section>
					<p>O Merge Sort pode ser implementado de forma iterativa ou recursiva. A versão recursiva é mais
						comum e fácil de entender, mas pode causar problemas de desempenho para listas muito grandes
						devido à sobrecarga da pilha de chamadas. Já a versão iterativa é mais eficiente em termos de
						espaço e pode ser mais rápida para listas pequenas.</p>
				</section>
				<section>
					<p>Em resumo, o Merge Sort é um algoritmo de classificação eficiente e estável que divide a lista em
						duas metades, ordena cada metade e combina as duas metades ordenadas em uma única lista
						ordenada. Ele é amplamente utilizado em situações em que há uma grande quantidade de dados para
						serem ordenados e é adequado para dados armazenados em mídia externa. No entanto, requer uma
						quantidade adicional de memória para a lista auxiliar durante a etapa de combinação</p>
				</section>
				<section>
					<p></p>
				</section>
			</section>
			<section>
				<h2>Complexidade</h2>
				<section>
					<p>
						A equação de recorrência do Merge Sort é T(n)=2T(n/2)+Θ(n)
						O termo 2T(n/2) é o tempo para ordenar dois vetores de tamanho n/2, já o termo Θ(n) é o tempo
						para fundir/intercalar esses vetores, isto é, é o tempo do método merge.

					</p>
				</section>
				<section>
					<p>A equação de recorrência anterior já foi resolvida algumas vezes em postagens anteriores do blog,
						porém resolveremos de novo.</p>
				</section>
				<section>
					<p>
						Podemos utilizar o método de Akra-Bazzi ou o método mestre na resolução. Optaremos pelo segundo.
						De acordo com o teorema mestre, temos
						a=2, b=2, f(n)=Θ(n)

					</p>
				</section>
				<section>
					<p>
						Além disso,
						a =2 =1
						Como f(n)=Θ(na )=Θ(n), então a equação de recorrência satisfaz o segundo caso do teorema mestre,
						portanto
						T(n)=Θ(na )logn)=Θ(nlogn)
						Ou, equivalentemente, T(n)=O(nlogn). Essa complexidade é a mesma no melhor caso, no caso médio e
						no pior caso.

					</p>
				</section>
			</section>
			<section>
				<h3>Implementação em C</h3>
				<section>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
						#include <stdio.h>
							#include <stdlib.h>
							
							static void merge(int A[], int inicio, int meio, int fim) {
								int tamEsq = meio - inicio + 1; //tamanho do subvetor esquerdo
								int tamDir = fim - meio; //tamanho do subvetor direito
								int esq[tamEsq]; //subvetor auxiliar esquerdo
								int dir[tamDir]; //subvetor auxiliar direito
								int idxEsq = 0; //índice do subvetor auxiliar esquerdo
								int idxDir = 0; //índice do subvetor auxiliar direito
								int i, j, k;
								
								//Copia os elementos do subvetor esquerdo para o vetor auxiliar
								for (i = 0; i < tamEsq; i++) {
									esq[i] = A[inicio + i];
								}
								//Copia os elementos do subvetor direito para o vetor auxiliar
								for (j = 0; j < tamDir; j++) {
									dir[j] = A[meio + 1 + j];
								}
							
								//intercala os vetores
								for (k = inicio; k <= fim; k++) {
									if (idxEsq < tamEsq) {
										if (idxDir < tamDir) {
											if (esq[idxEsq] < dir[idxDir]) {
												A[k] = esq[idxEsq++];
											} else {
												A[k] = dir[idxDir++];
											}
										} else {
											A[k] = esq[idxEsq++];
										}
									} else {
										A[k] = dir[idxDir++];
									}
								}
							}
							
							/*
							 * Algoritmo de ordenação por intercação/fusão
							 * 
							 * Adaptado o livro "Algoritmos: teoria e prática" (Cormen et al)
							 * 
							 * 'A' é o vetor de inteiros que será ordenado, 'inicio' é o indice inicial
							 * e 'fim' é o índice final
							 * Melhor caso: O(n log n)
							 * Caso médio: O(n log n)
							 * Pior caso: O(n log n)
							 */
							void mergeSort(int A[], int inicio, int fim) {
								if (inicio < fim) {
									int meio = (inicio + fim) / 2; //calcula o meio
									mergeSort(A, inicio, meio); //ordena do subvetor esquerdo
									mergeSort(A, meio + 1, fim); //ordena do subvetor direito
									merge(A, inicio, meio, fim); //funde os subvetores esquerdo e direito
								}
							}
							
							int main() {
								//testa o merge sort para vetores inteiros
								int n = 10;
								int A[10] = {5, 2, 7, 6, 2, 1, 0, 3, 9, 4};
								printf("A (desordenado) = [%d, %d, %d, %d, %d, %d, %d, %d, %d, %d]\n",
										A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9]);
								mergeSort(A, 0, n - 1);
								printf("A (ordenado) = [%d, %d, %d, %d, %d, %d, %d, %d, %d, %d]\n",
										A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9]);
								return 0;
							}
							

						
						</code></pre>
				</section>
			</section>
			<section>
				<h2>Insertion sort</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>Insertion sort ou ordenação por inserção é o método(algoritmo) de ordenação que percorre um vetor de elementos da esquerda para a direita e à medida que avança vai ordenando os elementos à esquerda. </p>
				</section>
				<section>
					<p>O Insertion sort é um algoritmo simples e eficiente quando aplicado em pequenas listas. Neste algoritmo a lista é percorrida da esquerda para a direita, à medida que avança vai deixando os elementos mais à esquerda ordenados.
					</p>
				</section>
				<section>
					<p>O algoritmo funciona da mesma forma que as pessoas usam para ordenar cartas em um jogo de baralho como o pôquer.</p>
				</section>
			</section>
			<section>
				<h3>Complexidade ou Características</h3>
				<section>
					<p>Apesar de ser menos eficiente do que algoritmos como Merge Sort e Quick Sort (de ordem O(nlog(n))), o Insertion Sort possui algumas características consideráveis:
					</p>
				</section>
				<section>
					<ul>
						<li>É de simples implementação, leitura e manutenção;</li>
						<li>In-place: Apenas requer uma quantidade constante de O(1) espaço de memória adicional;</li>
						<li>Estável: Não muda a ordem relativa de elementos com valores iguais;</li>
						<li>Útil para pequenas entradas;</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Muitas trocas, e menos comparações;</li>
						<li>Melhor caso: C(n)=O(n), quando a matriz está ordenado;</li>
						<li>Médio caso: O(n²/4), quando a matriz tem valores aleatórios sem ordem de classificação (crescente ou decrescente);</li>
						<li>Pior caso: C(n)=O(n²), quando a matriz está em ordem inversa, daquela que deseja ordenar.</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Vantagens e Desvantagens</h3>
				<section>
					<p>Vantagens</p>
					<ul>
						<li>É o método a ser utilizado quando o arquivo está "quase" ordenado.</li>
						<li>É um bom método quando se desejar adicionar poucos elementos em um arquivo já ordenado, pois seu custo é linear.</li>
						<li>O algoritmo de ordenação por inserção é estável.</li>
					</ul>
				</section>
				<section>
					<p>Desvantagens</p>
					<ul>
						<li>É considerado um método de ordenação estável. </li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Implementação em C</h3>
				<pre data-id="code-animation">
					<code class="hljs javascript" data-trim data-line-numbers>
						#include <math.h>
							#include <stdio.h>
							
							
							void insertionSort(int arr[], int size){
								int i, j, key;
								for (i = 1; i < size; i++) {
									key = arr[i];
									j = i - 1;
									while (j >= 0 && arr[j] > key) {
										arr[j + 1] = arr[j];
										j = j - 1;
									}
									arr[j + 1] = key;
								}
							}
							
							
							void printArray(int arr[], int size){
								int i;
								for (i = 0; i < size; i++)
									printf("%d ", arr[i]);
								printf("\n");
							}
							
							
							void main(){
								int arr[] = { 12, 11, 13, 5, 6 };
								int size = sizeof(arr) / sizeof(arr[0]);
								insertionSort(arr, size);
								printArray(arr, size);
							}
							
					</code>
				</pre>
			</section>

			<!-- HEAP SORT -->
			<section data-transition="zoom">
				<img src="img/heap-capa.gif" alt="">
				<h2>HEAP SORT</h2>

			</section>
			<section>
				<h3>introdução - heap sort</h3>
				<section>
					<p>O algoritmo heapsort é um algoritmo de ordenação generalista, e faz parte da família de algoritmos de ordenação por seleção. Foi desenvolvido em 1964 por Robert W. Floyd e J.W.J Williams. </p>
				</section>
				<section>
					<p>
						Heap sort é uma técnica de classificação baseada em comparação com base na estrutura de dados Binary Heap . É semelhante à classificação por seleção , onde primeiro encontramos o elemento mínimo e colocamos o elemento mínimo no início. Repita o mesmo processo para os restantes elementos.
					</p>
				</section>
				<section>
					<p>
						Tem um desempenho em tempo de execução muito bom em conjuntos ordenados aleatoriamente, tem um uso de memória bem comportado e o seu desempenho em pior cenário é praticamente igual ao desempenho em cenário médio. 
					</p>
				</section>
				<section>
					<p>
						Alguns algoritmos de ordenação rápidos têm desempenhos espectacularmente ruins no pior cenário, quer em tempo de execução, quer no uso da memória. O heapsort trabalha no lugar e o tempo de execução em pior cenário para ordenar n elementos é de O (n lg n).
					</p>
				</section>
			</section>
			<section>
				<h3>HEAP</h3>
				<section>
					<p>O Primeiro passo para o entendimento do HEAP SORT é o conhecimento sobre HEAP</p>
					<p>Um heap é uma árvore, normalmente uma árvore binária, na qual cada nodo filho tem um valor inferior a de seu pai, assim o nódo raiz é o maior nodo da árvore. Também podemos optar por orientar um heap de forma que cada nodo filho tenha um valor superiora de sue pai, neste caso o nodo da raíz é o de menor valor da árvore.</p>
				</section>
				<section>
					<p>
						Árvores como estas são parcialmente classificadas porque, apesar dos nodos ao longo de cada ramificação terem uma classificação específica, os nodos em um nível não estão necessáriamente calssificados de acordo com a organização dos nodos em outra ramificação.
					</p>
				</section>
				<section>
					<h4>Tipos de HEAP</h4>
					<p>Existem dois tipos de heap, que são:</p>
				</section>
				<section>
					<h5>Heap Máximo</h5>
					<p>Também chamado de pesado em cima,  é um heap em que cada filho é menor que seu pai, isso ocorre porque o maior nodo está no topo e suas propriedades são:</p>
					<ul>
						<li>A[pai(i)] >= A[i] => O valor de um nó é no máximo o valor de seu pai</li>
						<li>O Maior elemento de um heap está na raiz</li>
						<li>As sub-árvores de um nó possuem valores menores ou iguais ao do nó</li>
					</ul>
				</section>
				<section>
					<h5> Heap Minimo</h5>
					<p>Também chamado de pesado em baxo,  é um heap em que cada maior que seu pai, isso ocorre porque o menor nodo está no topo.  e suas propriedades são:</p>
					<ul>
						<li>A[pai(i)] <= A[i] => O valor de um nó é maior ou igual ao de seu pai</li>
						<li>O menor elemento de um heap está na raiz</li>
						<li>As sub-árvores de um nó possuem valores maiores ou iguais ao do nó</li>
					</ul>
				</section>
				<section>
					<h4>Organização de um heap</h4>
					<p>os heaps são balanciados pela esquerda, e os nodos são inseridos na árvore nível após nível, da esquerda para a direita.</p>
				</section>
				<section>
					<p>Considerando um array de indice 0 (zero), isso significa que o pai de cada nodo em uma posição i no array, estará localizado na posição | (i - 1) / 2 |, ignorando a parte fracionaria de (i - 1)/2</p>
				</section>
				<section>
					<ul>
						<li> Os filhos a esquerda estão localizados nas posições (2 * i + 1);</li>
						<li> Os filhos a direira estão localizados em (2 * i + 2)</li>
						<li> O último nodo é aquele mais a esquerda no nível mais profundo.</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Complexidade</h3>
				<section>
					<ul>
						<li>Comparações no pior caso: 2n log2n + O(n) é o mesmo que 2n log n + O(n)</li>
						<li>Trocas no pior caso: n log2n + O(n) é o mesmo que n log n + O(n)</li>
						<li>Melhor e pior caso: O(n log2n) é o mesmo que O(n log n)</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Funcionamento</h3>
				<section>
					<p>O heapsort utiliza uma estrutura de dados chamada heap, para ordenar os elementos à medida que os insere na estrutura. Assim, ao final das inserções, os elementos podem ser sucessivamente removidos da raiz da heap, na ordem desejada, lembrando-se sempre de manter a propriedade de max-heap. </p>
				</section>
				<section>
					<p>A heap pode ser representada como uma árvore (uma árvore binária com propriedades especiais[1]) ou como um vetor. Para uma ordenação decrescente, deve ser construída uma heap mínima (o menor elemento fica na raiz). Para uma ordenação crescente, deve ser construído uma heap máxima (o maior elemento fica na raiz). </p>
				</section>
				<section>
					<p>O Esquema abaixo mostra o funcionamento do heap sort</p>
					<img src="img/Heapsort-example.gif" alt="">
				</section>
			</section>
			<section>
				<h3>Estabilidade</h3>
				<section>
					O heapsort não é um algoritmo de ordenação estável. Porém, é possível adaptar a estrutura a ser ordenada de forma a tornar a ordenação estável. Cada elemento da estrutura adaptada deve ficar no formato de um par (elemento original, índice original). Assim, caso dois elementos sejam iguais, o desempate ocorrerá pelo índice na estrutura original. 
				</section>
			</section>
			<section>
				<h3>Vantagens e desvantagens</h3>
				<section>
					<p>Vantagens </p>
					<ul>
						<li>Simplicidade –  É mais simples de entender do que outros algoritmos de classificação igualmente eficientes porque não usa conceitos avançados de ciência da computação, como recursão.</li>
						<li>Uso de memória – O uso de memória é mínimo porque, além do necessário para manter a lista inicial de itens a serem classificados, não precisa de espaço de memória adicional para funcionar</li>
					</ul>
				</section>
				<section>
					<p>Vantagens</p>
					<ul>
						<li>Eficiência –  O tempo necessário para realizar a ordenação do Heap aumenta logaritmicamente, enquanto outros algoritmos podem crescer exponencialmente mais lentos à medida que o número de itens a classificar aumenta. Este algoritmo de ordenação é muito eficiente.</li>
					</ul>
				</section>
				<section>
					<p>Desvantagens</p>
					<ul>
						<li>Caro - a classificação de heap é cara.</li>
						<li>Instável - a classificação do heap é instável. Pode reorganizar a ordem relativa.</li>
						<li>Eficiente - Heap Sort não é muito eficiente ao trabalhar com dados altamente complexos. </li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Implementação em C</h3>
				<section>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							#include <stdio.h>
							 
							// Function to swap the position of two elements
							// função para trocar a posição de dois elementos
							 
							void swap(int* a, int* b)
							{
							 
								int temp = *a;
							 
								*a = *b;
							 
								*b = temp;
							}
							 
							// To heapify a subtree rooted with node i
							// which is an index in arr[].
							// n is size of heap
							void heapify(int arr[], int N, int i)
							{
								// Find largest among root, left child and right child
							 
								// Initialize largest as root
								int largest = i;
							 
								// left = 2*i + 1
								int left = 2 * i + 1;
							 
								// right = 2*i + 2
								int right = 2 * i + 2;
							 
								// If left child is larger than root
								if (left < N && arr[left] > arr[largest])
							 
									largest = left;
							 
								// If right child is larger than largest
								// so far
								if (right < N && arr[right] > arr[largest])
							 
									largest = right;
							 
								// Swap and continue heapifying if root is not largest
								// If largest is not root
								if (largest != i) {
							 
									swap(&arr[i], &arr[largest]);
							 
									// Recursively heapify the affected
									// sub-tree
									heapify(arr, N, largest);
								}
							}
							 
							// Main function to do heap sort
							void heapSort(int arr[], int N)
							{
							 
								// Build max heap
								for (int i = N / 2 - 1; i >= 0; i--)
							 
									heapify(arr, N, i);
							 
								// Heap sort
								for (int i = N - 1; i >= 0; i--) {
							 
									swap(&arr[0], &arr[i]);
							 
									// Heapify root element to get highest element at
									
									// root novamente
									heapify(arr, i, 0);
								}
							}
							 
							// uma função para imprimir o array
							void printArray(int arr[], int N)
							{
								for (int i = 0; i < N; i++)
									printf("%d ", arr[i]);
								printf("\n");
							}
							 
							// Função principal
							int main()
							{
								int arr[] = { 12, 11, 13, 5, 6, 7 };
								int N = sizeof(arr) / sizeof(arr[0]);
							 
								// Chamando as funções
								heapSort(arr, N);
								printf("Sorted array is\n");
								printArray(arr, N);
							}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h3>Conclusão</h3>
				<section>
					<p>
						Em conclusão, o estudo e implementação de algoritmos de ordenação de dados é fundamental para o desenvolvimento de sistemas eficientes e otimizados. Por meio deste trabalho, aprendemos sobre diversos algoritmos de ordenação, como Selection Sort, Insertion Sort, Merge Sort, Quick Sort e Heap Sort, e entendemos as vantagens e desvantagens de cada um deles.
					</p>
				</section>
				<section>
					<p>Além disso, aprendemos a importância da análise assintótica, que nos permite avaliar a eficiência de um algoritmo em termos de seu tempo de execução e uso de recursos. Com base nessa análise, pudemos avaliar a complexidade de cada algoritmo e identificar aqueles que são mais adequados para diferentes tipos de conjuntos de dados.</p>
				</section>
				<section>
					<p>Concluímos, portanto, que a escolha do algoritmo de ordenação correto é crucial para obter um desempenho eficiente em sistemas que lidam com grandes quantidades de dados. Embora cada algoritmo tenha suas próprias vantagens e desvantagens, a escolha deve levar em consideração o tamanho do conjunto de dados, a complexidade do algoritmo e as restrições de recursos do sistema.</p>
				</section>
				<section>
					<p>Em resumo, este trabalho foi uma oportunidade valiosa para aprimorar nossos conhecimentos em algoritmos de ordenação e sua aplicação prática, preparando-nos para enfrentar desafios na área de processamento de dados e desenvolvimento de sistemas mais eficientes e otimizados.</p>
				</section>
			</section>
			<section>
				<h3>Referências Bibliográficas</h3>
				<section>
					<ul>
						<li>Donald Knuth. The Art of Computer Programming, Volume 3: Sorting and Searching, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Section 5.2.1: Sorting by Insertion, pp. 80–105.</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0262032937. Section 2.1: Insertion sort, pp. 15–21.</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Michael T Goodrich, Algorithm Desing: Foundations, Analysis and Internet Examples, Second Edition. 2002, ISBN 0-471-38365-1. Section 4.4.6; Comparison of Sorting Algorithms, pp. 244-245.</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Robert Sedgewick, Philippe Flajolet, An Introduction to the Analysis of Algorithms, Second Edition, Pearson Education, 2013. ISBN-13: 978-0-321-90575-8. Section 7.6: Inversions and Insertion Sorts, pp. 384-388.</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Ziviani, N. (2004). Projeto de algoritmos: com implementações em Pascal e C (Vol. 2). Luton: Thomson.</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Soffner, R. (2017). Algoritmos e programação em linguagem C. Saraiva Educação SA.</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Souza, J. E., Ricarte, J. V. G., & de Almeida Lima, N. C. (2017). Algoritmos de Ordenação: Um estudo comparativo. Anais do Encontro de Computação do Oeste Potiguar ECOP/UFERSA (ISSN 2526-7574), (1).</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Participantes</h3>
				<p>GRUPO Nº 1</p>
				<ul>
					<li>Bernardo Sacuendi-20211372</li>
					<li>Emiliano Salvador-20211147</li>
					<li>Leossandro Correia-20210341</li>
					<li>Miguel Adolfo-20211983</li>
				</ul>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>