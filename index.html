<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>ALGORITMOS DE ORDENAÇÃO DE DADOS</h2>
			</section>
			<section>
				<h3>Este Trabalho</h3>
				<section>
					<p>O Presente trabalho descreve os algoritmos de odenação citados abaixo, baseando-se no
						funcionamento, complexibilidade, estabilidade, representação gráfica e a devida implementação na
						linguadem de programação C</p>
				</section>
				<section>
					<ul>
						<li>Insertion Sort</li>
						<li>Quick Sort</li>
						<li>Shel Sort</li>
						<li>Heap Sort</li>
						<li>Merge Sort</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>INTRODUÇÃO</h3>
				<section>
					<P>Os algoritmos de ordenação são um conjunto de procedimentos que visam organizar uma sequência de
						dados em ordem crescente ou decrescente. </P>
				</section>
				<section>
					<p>Eles são amplamente utilizados em diversas áreas, desde a organização de dados em bancos de dados
						até a criação de gráficos e tabelas em softwares de análise de dados.</p>
				</section>
				<section>
					<p>
						Existem vários tipos de algoritmos de ordenação, cada um com suas próprias características e
						vantagens. Alguns exemplos incluem o Bubble Sort, o Insertion Sort, o Selection Sort, o Merge
						Sort, o Quick Sort, o Shell Sort e o Heap Sort.
					</p>
				</section>
				<section>
					<p>A escolha do algoritmo mais adequado depende do tipo de dados que estão sendo ordenados, do
						tamanho da lista e das necessidades específicas da aplicação.</p>
				</section>
			</section>
			<section>
				<h2>QUICK SORT</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>Quick Sort é um algoritmo eficiente de ordenação por divisão e conquista. Apesar de ser da
						mesma classe de complexidade do  Merge Sort  e do  Heap Sort , o Quick Sort é na prática o
						mais veloz deles, pois suas constantes são menores.</p>
				</section>
				<section>
					<p>
						Foi proposto por Hoare em 1960 e publicado em 1962. É o algoritmo de ordenação interna
						mais rápido que se conhece para uma ampla variedade de situações.
					</p>
				</section>
			</section>
			<section>
				<h3>Funcionamento</h3>
				<section>
					<p>
						O funcionamento do Quick Sort baseia-se em uma rotina fundamental cujo nome
						é particionamento. Particionar significa escolher um número qualquer presente no array,
						chamado de pivot, e colocá-lo em uma posição tal que todos os elementos à esquerda são
						menores ou iguais e todos os elementos à direita são maiores.
					</p>
				</section>
				<section>
					<p>
						A idéia básica do quick sort é dividir o problema de ordenar um conjunto com n itens em
						dois sub-problemas menores.
					</p>
				</section>

			</section>
			<section>
				<h2>Vantagens e Desvantagens</h2>
				<section>
					<p>Vantagens</p>
					<ul>
						<li>É extremamente eficiente para ordenar arquivos de dados.</li>
						<li>Necessita de apenas uma pequena pilha como memória auxiliar.</li>
						<li>Requer O(n log n) comparações em média (caso médio) para ordenar n itens.</li>
					</ul>
				</section>
				<section>
					<p>Desvantagens</p>
					<ul>
						<li>Tem um pior caso O(n2) comparações.</li>
						<li>Sua implementação é delicada e difícil</li>
						<li>Um pequeno engano pode levar a efeitos inesperados para algumas entradas de dados.</li>
						<li>O método não é estável.</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Complexidade</h2>
				<section>
					<p>Sua complexidade no tempo é O(nlogn) no melhor caso e no caso médio e O(n^2) no pior
						caso. Contudo, em geral, o Quicksort apresenta um desempenho superior a outros
						algoritmos similares, como o Merge Sort.</p>
				</section>
			</section>
			<section>
				<h2>Estabilidade</h2>
				<section>
					<p>O Quick Sort não é um algoritmo estável. O modo como o particiona é implementado
						permite que elementos iguais troquem de posições relativas durante a sua execução.</p>
				</section>
				<section>
					<p>É possível implementar uma versão estável do Quick Sort, mas para isso, ao invés de trocar
						o pivot diretamente com a primeira posição, o algoritmo deve fazer sucessivas trocas para
						“afastar” o pivot até a posição desejada – um processo semelhante à inserção ordenada.
						Essa implementação, contudo, piora significativamente o desempenho do Quick Sort.</p>
				</section>
			</section>
			<section>
				<h2>Metodo de partição
				</h2>
				<section>
					<p>Algoritmo para o particionamento</p>
					<ul>
						<li>1 - Escolha arbitrariamente um pivô x. </li>
						<li>2 - Percorra o vetor a partir da esquerda até que v[i] ≥ x. </li>
						<li>3 - Percorra o vetor a partir da direita até que v[j] ≤ x. </li>
						<li>4 - Troque v[i] com v[j]. </li>
						<li>5 - Continue este processo até os apontadores i e j se cruzarem.</li>
					</ul>
				</section>
				<section>
					<p>Ao final, do algoritmo de partição:</p>
					<ul>
						<li>Vetor v[esq..dir] está particionado de tal forma que:</li>
						<li>Os itens em v[esq], v[esq + 1], ..., v[j] são menores ou iguais a x;</li>
						<li>Os itens em v[i], v[i + 1], ..., v[dir] são maiores ou iguais a x.</li>
					</ul>
				</section>
			</section>
			<section>
				<h2 data-id="code-title">Implementação em C</h2>
				<section>
					<p>Particionar usando o esquema de particionamento de Hoare</p>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						int partition(int a[], int low, int high)
						{
							int pivot = a[low];
							int i = low - 1;
							int j = high + 1;
							while (1)
							{
								do {
									i++;
								} while (a[i] < pivot);
						 
								do {
									j--;
								} while (a[j] > pivot);
						 
								if (i >= j) {
									return j;
								}
						 
								swap(a[i], a[j]);
							}
						}
						
						</code></pre>
				</section>
				<section>
					<p>Rotina de classificação rápida</p>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						void quicksort(int a[], int low, int high)
						{
							// condição básica
							if (low >= high) {
								return;
							}
						
							// reorganiza os elementos no pivô
							int pivot = partition(a, low, high);
						
							// se repete no subarray contendo elementos que são menores que o pivô
							quicksort(a, low, pivot);
						
							//recorre em subarray contendo elementos que são maiores que o pivô
							quicksort(a, pivot + 1, high);
						}

						
						</code></pre>
				</section>
				<section>
					<p>Função main()</p>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						int main()
						{
							int arr[10] = {12, 8, 9, 12, 4, 3, 9, 29, 10, 1};
						
							quicksort(arr, 0, 9);
							
							//apresentando o vetor ordenado
							for (int i = 0; i < N; i++) {
								printf("%d\n", arr[i]);
							}
						
							return 0;
						}


						</code></pre>
				</section>
			</section>
			<section>
				<h2>SHELL SORT</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>ShellSort é uma versão aprimorada do algoritmo de InsertionSort, diferindo pelo fato de no lugar
						de considerar o vetor a ser ordenado como um único segmento, ele considera vários segmentos
						sendo aplicado o método de inserção direta em cada um deles. Basicamente o algoritmo passa
						várias vezes pela lista dividindo o grupo maior em menores. </p>
				</section>
				<section>
					<p>
						O algoritmo é eficiente mas razão da sua eficiência ainda não é conhecida, pois ninguém ainda
						foi capaz de analisar o algoritmo a sua análise contém alguns problemas matemáticos muito
						difíceis.
					</p>
				</section>
			</section>
			<section>
				<h3>Funcionamento</h3>
				<section>
					<p>
						O Shellsort troca elementos distantes um do outro. Os itens separados por h posições são
						agrupados e ordenados, o valor de h é decrementado seguindo uma sequencia qualquer (não há uma
						sequencia definitiva) até que atinja o valor unitário, onde a ordenação corresponde ao algoritmo
						de inserção, mas nesse ponto nenhum elemento precisa se mover para uma posição muito distante.
					</p>
				</section>
			</section>
			<section>
				<h3>Complexidade</h3>
				<section>
					<p>A complexidade do algoritmo ainda não é conhecida, ninguém ainda foi capaz de encontrar uma
						fórmula fechada para sua função de complexidade. A sua análise contém alguns problemas
						matemáticos muito difíceis.
					</p>
				</section>
				<section>
					<p>

					</p>
				</section>
			</section>
			<section>
				<h3>Estabilidade</h3>
				<section>
					<p>A complexidade do algoritmo ainda não é conhecida, ninguém ainda foi capaz de encontrar uma
						fórmula fechada para sua função de complexidade. A sua análise contém alguns problemas
						matemáticos muito difíceis.
					</p>
				</section>
				<section>
					<p>
						Quanto a essa característica o algoritmo não é estável
					</p>
				</section>
			</section>
			<section>
				<h3>Estabilidade</h3>
				<section>
					<p>A complexidade do algoritmo ainda não é conhecida, ninguém ainda foi capaz de encontrar uma
						fórmula fechada para sua função de complexidade. A sua análise contém alguns problemas
						matemáticos muito difíceis.
					</p>
				</section>
				<section>
					<p>
						Quanto a essa característica o algoritmo não é estável
					</p>
				</section>
			</section>
			<section>
				<h3>Representação Gráfica</h3>

			</section>
			<section>
				<h3>Implementação Em C</h3>
				<section>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						#include <stdio.h>


							// Shell sort
							void shellSort(int v[], int n) {
							  // Rearrange elements at each n/2, n/4, n/8, ... intervals
							  for (int interval = n / 2; interval > 0; interval /= 2) {
								for (int i = interval; i < n; i += 1) {
								  int temp = v[i];
								  int j;
								  for (j = i; j >= interval && v[j - interval] > temp; j -= interval) {
									v[j] = v[j - interval];
								  }
									v[j] = temp;
								}
							  }
							}
							
							
							// Print an array
							void printv(int v[], int size) {
							  for (int i = 0; i < size; ++i) {
								printf("%d  ", v[i]);
							  }
							  printf("\n");
							}
							
							
							// Driver code
							int main() {
							  int m[] = {9, 8, 3, 7, 5, 6, 4, 1};
							  int size = sizeof(m) / sizeof(m[0]);
							  shellSort(m, size);
							  printf("Sorted array: \n");
							  printv(m, size);
							}
							

						
						</code></pre>
				</section>
			</section>
			<section>
				<h2>Merge Sort</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>O algoritmo de ordenação Merge Sort é um algoritmo de classificação eficiente e recursivo, que
						divide a lista em duas metades iguais, ordena cada metade e, em seguida, combina as duas metades
						ordenadas em uma única lista ordenada.</p>
				</section>
				<section>
					<p>O algoritmo funciona da seguinte maneira:</p>
					<ul>
						<li>Divida a lista em duas metades iguais.</li>
						<li>Ordena recursivamente cada metade.</li>
						<li>Combina as duas metades ordenadas em uma única lista ordenada.</li>
					</ul>
				</section>
				<section>
					<p>
						Divida a lista em duas metades iguais.
						Ordena recursivamente cada metade.
						Combina as duas metades ordenadas em uma única lista ordenada.
					</p>
				</section>
				<section>
					<p>
						Esse processo de dividir, ordenar e combinar é repetido recursivamente até que a lista inteira
						seja ordenada.
					</p>
				</section>
				<section>
					<p>O Merge Sort é um algoritmo eficiente com uma complexidade de tempo de O(nlogn), onde n é o
						tamanho da lista. Ele é amplamente utilizado na prática, especialmente quando há uma grande
						quantidade de dados para serem ordenados.</p>
				</section>
				<section>
					<p>Uma das principais vantagens do Merge Sort é que ele é um algoritmo de classificação estável, o
						que significa que ele preserva a ordem relativa dos elementos com chaves iguais. Além disso, o
						Merge Sort é adequado para dados armazenados em mídia externa, como arquivos, porque minimiza o
						número de acessos ao disco.</p>
				</section>
				<section>
					<p>No entanto, o Merge Sort requer uma quantidade adicional de memória para a lista auxiliar durante
						a etapa de combinação, o que pode ser um problema em algumas situações.</p>
				</section>
				<section>
					<p>O Merge Sort pode ser implementado de forma iterativa ou recursiva. A versão recursiva é mais
						comum e fácil de entender, mas pode causar problemas de desempenho para listas muito grandes
						devido à sobrecarga da pilha de chamadas. Já a versão iterativa é mais eficiente em termos de
						espaço e pode ser mais rápida para listas pequenas.</p>
				</section>
				<section>
					<p>Em resumo, o Merge Sort é um algoritmo de classificação eficiente e estável que divide a lista em
						duas metades, ordena cada metade e combina as duas metades ordenadas em uma única lista
						ordenada. Ele é amplamente utilizado em situações em que há uma grande quantidade de dados para
						serem ordenados e é adequado para dados armazenados em mídia externa. No entanto, requer uma
						quantidade adicional de memória para a lista auxiliar durante a etapa de combinação</p>
				</section>
				<section>
					<p></p>
				</section>
			</section>
			<section>
				<h2>Complexidade</h2>
				<section>
					<p>
						A equação de recorrência do Merge Sort é T(n)=2T(n/2)+Θ(n)
						O termo 2T(n/2) é o tempo para ordenar dois vetores de tamanho n/2, já o termo Θ(n) é o tempo
						para fundir/intercalar esses vetores, isto é, é o tempo do método merge.

					</p>
				</section>
				<section>
					<p>A equação de recorrência anterior já foi resolvida algumas vezes em postagens anteriores do blog,
						porém resolveremos de novo.</p>
				</section>
				<section>
					<p>
						Podemos utilizar o método de Akra-Bazzi ou o método mestre na resolução. Optaremos pelo segundo.
						De acordo com o teorema mestre, temos
						a=2, b=2, f(n)=Θ(n)

					</p>
				</section>
				<section>
					<p>
						Além disso,
						a =2 =1
						Como f(n)=Θ(na )=Θ(n), então a equação de recorrência satisfaz o segundo caso do teorema mestre,
						portanto
						T(n)=Θ(na )logn)=Θ(nlogn)
						Ou, equivalentemente, T(n)=O(nlogn). Essa complexidade é a mesma no melhor caso, no caso médio e
						no pior caso.

					</p>
				</section>
			</section>
			<section>
				<h3>Implementação em C</h3>
				<section>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
						#include <stdio.h>
							#include <stdlib.h>
							
							static void merge(int A[], int inicio, int meio, int fim) {
								int tamEsq = meio - inicio + 1; //tamanho do subvetor esquerdo
								int tamDir = fim - meio; //tamanho do subvetor direito
								int esq[tamEsq]; //subvetor auxiliar esquerdo
								int dir[tamDir]; //subvetor auxiliar direito
								int idxEsq = 0; //índice do subvetor auxiliar esquerdo
								int idxDir = 0; //índice do subvetor auxiliar direito
								int i, j, k;
								
								//Copia os elementos do subvetor esquerdo para o vetor auxiliar
								for (i = 0; i < tamEsq; i++) {
									esq[i] = A[inicio + i];
								}
								//Copia os elementos do subvetor direito para o vetor auxiliar
								for (j = 0; j < tamDir; j++) {
									dir[j] = A[meio + 1 + j];
								}
							
								//intercala os vetores
								for (k = inicio; k <= fim; k++) {
									if (idxEsq < tamEsq) {
										if (idxDir < tamDir) {
											if (esq[idxEsq] < dir[idxDir]) {
												A[k] = esq[idxEsq++];
											} else {
												A[k] = dir[idxDir++];
											}
										} else {
											A[k] = esq[idxEsq++];
										}
									} else {
										A[k] = dir[idxDir++];
									}
								}
							}
							
							/*
							 * Algoritmo de ordenação por intercação/fusão
							 * 
							 * Adaptado o livro "Algoritmos: teoria e prática" (Cormen et al)
							 * 
							 * 'A' é o vetor de inteiros que será ordenado, 'inicio' é o indice inicial
							 * e 'fim' é o índice final
							 * Melhor caso: O(n log n)
							 * Caso médio: O(n log n)
							 * Pior caso: O(n log n)
							 */
							void mergeSort(int A[], int inicio, int fim) {
								if (inicio < fim) {
									int meio = (inicio + fim) / 2; //calcula o meio
									mergeSort(A, inicio, meio); //ordena do subvetor esquerdo
									mergeSort(A, meio + 1, fim); //ordena do subvetor direito
									merge(A, inicio, meio, fim); //funde os subvetores esquerdo e direito
								}
							}
							
							int main() {
								//testa o merge sort para vetores inteiros
								int n = 10;
								int A[10] = {5, 2, 7, 6, 2, 1, 0, 3, 9, 4};
								printf("A (desordenado) = [%d, %d, %d, %d, %d, %d, %d, %d, %d, %d]\n",
										A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9]);
								mergeSort(A, 0, n - 1);
								printf("A (ordenado) = [%d, %d, %d, %d, %d, %d, %d, %d, %d, %d]\n",
										A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9]);
								return 0;
							}
							

						
						</code></pre>
				</section>
			</section>
			<section>
				<h2>Insertion sort</h2>
			</section>
			<section>
				<h3>Introdução</h3>
				<section>
					<p>Insertion sort ou ordenação por inserção é o método(algoritmo) de ordenação que percorre um vetor de elementos da esquerda para a direita e à medida que avança vai ordenando os elementos à esquerda. </p>
				</section>
				<section>
					<p>O Insertion sort é um algoritmo simples e eficiente quando aplicado em pequenas listas. Neste algoritmo a lista é percorrida da esquerda para a direita, à medida que avança vai deixando os elementos mais à esquerda ordenados.
					</p>
				</section>
				<section>
					<p>O algoritmo funciona da mesma forma que as pessoas usam para ordenar cartas em um jogo de baralho como o pôquer.</p>
				</section>
			</section>
			<section>
				<h3>Complexidade ou Características</h3>
				<section>
					<p>Apesar de ser menos eficiente do que algoritmos como Merge Sort e Quick Sort (de ordem O(nlog(n))), o Insertion Sort possui algumas características consideráveis:
					</p>
				</section>
				<section>
					<ul>
						<li>É de simples implementação, leitura e manutenção;</li>
						<li>In-place: Apenas requer uma quantidade constante de O(1) espaço de memória adicional;</li>
						<li>Estável: Não muda a ordem relativa de elementos com valores iguais;</li>
						<li>Útil para pequenas entradas;</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>Muitas trocas, e menos comparações;</li>
						<li>Melhor caso: C(n)=O(n), quando a matriz está ordenado;</li>
						<li>Médio caso: O(n²/4), quando a matriz tem valores aleatórios sem ordem de classificação (crescente ou decrescente);</li>
						<li>Pior caso: C(n)=O(n²), quando a matriz está em ordem inversa, daquela que deseja ordenar.</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Vantagens e Desvantagens</h3>
				<section>
					<p>Vantagens</p>
					<ul>
						<li>É o método a ser utilizado quando o arquivo está "quase" ordenado.</li>
						<li>É um bom método quando se desejar adicionar poucos elementos em um arquivo já ordenado, pois seu custo é linear.</li>
						<li>O algoritmo de ordenação por inserção é estável.</li>
					</ul>
				</section>
				<section>
					<p>Desvantagens</p>
					<ul>
						<li>É considerado um método de ordenação estável. </li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Implementação em C</h3>
				<pre data-id="code-animation">
					<code class="hljs javascript" data-trim data-line-numbers>
						#include <math.h>
							#include <stdio.h>
							
							
							void insertionSort(int arr[], int size){
								int i, j, key;
								for (i = 1; i < size; i++) {
									key = arr[i];
									j = i - 1;
									while (j >= 0 && arr[j] > key) {
										arr[j + 1] = arr[j];
										j = j - 1;
									}
									arr[j + 1] = key;
								}
							}
							
							
							void printArray(int arr[], int size){
								int i;
								for (i = 0; i < size; i++)
									printf("%d ", arr[i]);
								printf("\n");
							}
							
							
							void main(){
								int arr[] = { 12, 11, 13, 5, 6 };
								int size = sizeof(arr) / sizeof(arr[0]);
								insertionSort(arr, size);
								printArray(arr, size);
							}
							
					</code>
				</pre>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>